/* tslint:disable */
/* eslint-disable */
/**
 * ADCIO API:controller
 * The ADCIO API:controller specification
 *
 * The version of the OpenAPI document: v1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppendInjector
 */
export interface AppendInjector {
    /**
     * 
     * @type {string}
     * @memberof AppendInjector
     */
    'waitFor': string;
    /**
     * 
     * @type {string}
     * @memberof AppendInjector
     */
    'wrapper': string;
    /**
     * 
     * @type {string}
     * @memberof AppendInjector
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppendInjector
     */
    'imageTemplate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppendInjector
     */
    'videoTemplate'?: string;
}
/**
 * 
 * @export
 * @interface Banner
 */
export interface Banner {
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'type': BannerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof Banner
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'productId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Banner
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'endsAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'deletedAt': string | null;
}

export const BannerTypeEnum = {
    Video: 'video',
    Image: 'image'
} as const;

export type BannerTypeEnum = typeof BannerTypeEnum[keyof typeof BannerTypeEnum];

/**
 * 
 * @export
 * @interface BannerControllerFetchMany200Response
 */
export interface BannerControllerFetchMany200Response {
    /**
     * 
     * @type {number}
     * @memberof BannerControllerFetchMany200Response
     */
    'count'?: number;
    /**
     * 
     * @type {Array<FetchManyBannersResponseDto>}
     * @memberof BannerControllerFetchMany200Response
     */
    'items'?: Array<FetchManyBannersResponseDto>;
}
/**
 * 
 * @export
 * @interface BannerInjector
 */
export interface BannerInjector {
    /**
     * 
     * @type {Array<string>}
     * @memberof BannerInjector
     */
    'paths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BannerInjector
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof BannerInjector
     */
    'imageTemplate'?: string;
    /**
     * 
     * @type {string}
     * @memberof BannerInjector
     */
    'videoTemplate'?: string;
}
/**
 * 
 * @export
 * @interface BannerWithCreativeDto
 */
export interface BannerWithCreativeDto {
    /**
     * 
     * @type {Creative}
     * @memberof BannerWithCreativeDto
     */
    'creative': Creative;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'type': BannerWithCreativeDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof BannerWithCreativeDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'productId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BannerWithCreativeDto
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'endsAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BannerWithCreativeDto
     */
    'deletedAt': string | null;
}

export const BannerWithCreativeDtoTypeEnum = {
    Video: 'video',
    Image: 'image'
} as const;

export type BannerWithCreativeDtoTypeEnum = typeof BannerWithCreativeDtoTypeEnum[keyof typeof BannerWithCreativeDtoTypeEnum];

/**
 * 
 * @export
 * @interface CategoryWithPath
 */
export interface CategoryWithPath {
    /**
     * 
     * @type {string}
     * @memberof CategoryWithPath
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryWithPath
     */
    'idOnStore': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryWithPath
     */
    'storeId': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryWithPath
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryWithPath
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryWithPath
     */
    'path': Array<string>;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'currency': ClientCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'timezone': ClientTimezoneEnum;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'credit': number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'type': ClientTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'paymentCardId': string | null;
    /**
     * 
     * @type {Store}
     * @memberof Client
     */
    'store'?: Store | null;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'storeId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    'isSeller': boolean;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'createdAt': string;
}

export const ClientCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Vnd: 'VND'
} as const;

export type ClientCurrencyEnum = typeof ClientCurrencyEnum[keyof typeof ClientCurrencyEnum];
export const ClientTimezoneEnum = {
    Kst: 'KST',
    Ict: 'ICT',
    Est: 'EST',
    Cst: 'CST',
    Mst: 'MST',
    Pst: 'PST',
    Akst: 'AKST',
    Hst: 'HST'
} as const;

export type ClientTimezoneEnum = typeof ClientTimezoneEnum[keyof typeof ClientTimezoneEnum];
export const ClientTypeEnum = {
    PlatformAndSeller: 'PLATFORM_AND_SELLER',
    OwnWebsiteAndSeller: 'OWN_WEBSITE_AND_SELLER',
    Platform: 'PLATFORM',
    OwnWebsite: 'OWN_WEBSITE',
    Seller: 'SELLER',
    Admin: 'ADMIN'
} as const;

export type ClientTypeEnum = typeof ClientTypeEnum[keyof typeof ClientTypeEnum];

/**
 * 
 * @export
 * @interface CreateBannerDto
 */
export interface CreateBannerDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'type': CreateBannerDtoTypeEnum;
    /**
     * 
     * @type {Array<UpsertCreativeDto>}
     * @memberof CreateBannerDto
     */
    'creatives': Array<UpsertCreativeDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBannerDto
     */
    'placementIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'url'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateBannerDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'endsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerDto
     */
    'productId': string | null;
}

export const CreateBannerDtoTypeEnum = {
    Video: 'video',
    Image: 'image'
} as const;

export type CreateBannerDtoTypeEnum = typeof CreateBannerDtoTypeEnum[keyof typeof CreateBannerDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreatePlacementDto
 */
export interface CreatePlacementDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePlacementDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlacementDto
     */
    'pageName': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlacementDto
     */
    'type': CreatePlacementDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePlacementDto
     */
    'suggestionType': CreatePlacementDtoSuggestionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePlacementDto
     */
    'property': CreatePlacementDtoPropertyEnum;
    /**
     * 
     * @type {number}
     * @memberof CreatePlacementDto
     */
    'displayCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePlacementDto
     */
    'activated': boolean;
    /**
     * 
     * @type {PlacementInjectorDto}
     * @memberof CreatePlacementDto
     */
    'injector'?: PlacementInjectorDto;
}

export const CreatePlacementDtoTypeEnum = {
    Grid: 'GRID',
    Banner: 'BANNER'
} as const;

export type CreatePlacementDtoTypeEnum = typeof CreatePlacementDtoTypeEnum[keyof typeof CreatePlacementDtoTypeEnum];
export const CreatePlacementDtoSuggestionTypeEnum = {
    Recommend: 'RECOMMEND',
    Advertise: 'ADVERTISE'
} as const;

export type CreatePlacementDtoSuggestionTypeEnum = typeof CreatePlacementDtoSuggestionTypeEnum[keyof typeof CreatePlacementDtoSuggestionTypeEnum];
export const CreatePlacementDtoPropertyEnum = {
    New: 'NEW',
    Hot: 'HOT',
    Personal: 'PERSONAL',
    SameGoods: 'SAME_GOODS',
    DiffGoods: 'DIFF_GOODS'
} as const;

export type CreatePlacementDtoPropertyEnum = typeof CreatePlacementDtoPropertyEnum[keyof typeof CreatePlacementDtoPropertyEnum];

/**
 * 
 * @export
 * @interface CreateProductDto
 */
export interface CreateProductDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'idOnStore': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateProductDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateProductDto
     */
    'includeInRecommendation'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'sellerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'sellerIdOnStore'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'deepLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface Creative
 */
export interface Creative {
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'mediaUrl': string;
    /**
     * 
     * @type {number}
     * @memberof Creative
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof Creative
     */
    'height': number | null;
    /**
     * 
     * @type {PlacementFormat}
     * @memberof Creative
     */
    'placementFormat': PlacementFormat | null;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'placementFormatRatio': string | null;
    /**
     * 
     * @type {Banner}
     * @memberof Creative
     */
    'banner': Banner | null;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'bannerId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Creative
     */
    'deletedAt': string | null;
}
/**
 * 
 * @export
 * @interface FetchBannerResponseDto
 */
export interface FetchBannerResponseDto {
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'type': FetchBannerResponseDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof FetchBannerResponseDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'productId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof FetchBannerResponseDto
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'endsAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchBannerResponseDto
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {CategoryWithPath}
     * @memberof FetchBannerResponseDto
     */
    'category': CategoryWithPath | null;
    /**
     * 
     * @type {Product}
     * @memberof FetchBannerResponseDto
     */
    'product': Product | null;
    /**
     * 
     * @type {Array<Placement>}
     * @memberof FetchBannerResponseDto
     */
    'placements': Array<Placement>;
    /**
     * 
     * @type {Array<Creative>}
     * @memberof FetchBannerResponseDto
     */
    'creatives': Array<Creative>;
}

export const FetchBannerResponseDtoTypeEnum = {
    Video: 'video',
    Image: 'image'
} as const;

export type FetchBannerResponseDtoTypeEnum = typeof FetchBannerResponseDtoTypeEnum[keyof typeof FetchBannerResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface FetchManyBannersResponseDto
 */
export interface FetchManyBannersResponseDto {
    /**
     * 
     * @type {Array<Creative>}
     * @memberof FetchManyBannersResponseDto
     */
    'creatives': Array<Creative>;
    /**
     * 
     * @type {Array<Placement>}
     * @memberof FetchManyBannersResponseDto
     */
    'placements': Array<Placement>;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'type': FetchManyBannersResponseDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof FetchManyBannersResponseDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'productId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof FetchManyBannersResponseDto
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'endsAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyBannersResponseDto
     */
    'deletedAt': string | null;
}

export const FetchManyBannersResponseDtoTypeEnum = {
    Video: 'video',
    Image: 'image'
} as const;

export type FetchManyBannersResponseDtoTypeEnum = typeof FetchManyBannersResponseDtoTypeEnum[keyof typeof FetchManyBannersResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface FetchManyPlacementsResponseDto
 */
export interface FetchManyPlacementsResponseDto {
    /**
     * 
     * @type {FetchPageClientDto}
     * @memberof FetchManyPlacementsResponseDto
     */
    'page': FetchPageClientDto;
    /**
     * 
     * @type {Array<Product>}
     * @memberof FetchManyPlacementsResponseDto
     */
    'products': Array<Product>;
    /**
     * 
     * @type {Array<Banner>}
     * @memberof FetchManyPlacementsResponseDto
     */
    'banners': Array<Banner>;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'type': FetchManyPlacementsResponseDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'suggestionType': FetchManyPlacementsResponseDtoSuggestionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'supportEnvironment': FetchManyPlacementsResponseDtoSupportEnvironmentEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'developEnvironment': FetchManyPlacementsResponseDtoDevelopEnvironmentEnum;
    /**
     * 
     * @type {number}
     * @memberof FetchManyPlacementsResponseDto
     */
    'displayCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof FetchManyPlacementsResponseDto
     */
    'minDisplayCount': number;
    /**
     * 
     * @type {number}
     * @memberof FetchManyPlacementsResponseDto
     */
    'maxDisplayCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FetchManyPlacementsResponseDto
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'pageName': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'clientId': string;
    /**
     * 
     * @type {Injector}
     * @memberof FetchManyPlacementsResponseDto
     */
    'injector': Injector | null;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'screenShot': string;
    /**
     * 
     * @type {number}
     * @memberof FetchManyPlacementsResponseDto
     */
    'displayFormatWidth': number | null;
    /**
     * 
     * @type {number}
     * @memberof FetchManyPlacementsResponseDto
     */
    'displayFormatHeight': number | null;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'property': FetchManyPlacementsResponseDtoPropertyEnum;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'placementFormatRatio': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchManyPlacementsResponseDto
     */
    'deletedAt': string | null;
}

export const FetchManyPlacementsResponseDtoTypeEnum = {
    Grid: 'GRID',
    Banner: 'BANNER'
} as const;

export type FetchManyPlacementsResponseDtoTypeEnum = typeof FetchManyPlacementsResponseDtoTypeEnum[keyof typeof FetchManyPlacementsResponseDtoTypeEnum];
export const FetchManyPlacementsResponseDtoSuggestionTypeEnum = {
    Recommend: 'RECOMMEND',
    Advertise: 'ADVERTISE'
} as const;

export type FetchManyPlacementsResponseDtoSuggestionTypeEnum = typeof FetchManyPlacementsResponseDtoSuggestionTypeEnum[keyof typeof FetchManyPlacementsResponseDtoSuggestionTypeEnum];
export const FetchManyPlacementsResponseDtoSupportEnvironmentEnum = {
    Web: 'WEB',
    WebMobile: 'WEB_MOBILE',
    App: 'APP'
} as const;

export type FetchManyPlacementsResponseDtoSupportEnvironmentEnum = typeof FetchManyPlacementsResponseDtoSupportEnvironmentEnum[keyof typeof FetchManyPlacementsResponseDtoSupportEnvironmentEnum];
export const FetchManyPlacementsResponseDtoDevelopEnvironmentEnum = {
    Widget: 'WIDGET',
    SelfDeveloped: 'SELF_DEVELOPED',
    CodeInjector: 'CODE_INJECTOR'
} as const;

export type FetchManyPlacementsResponseDtoDevelopEnvironmentEnum = typeof FetchManyPlacementsResponseDtoDevelopEnvironmentEnum[keyof typeof FetchManyPlacementsResponseDtoDevelopEnvironmentEnum];
export const FetchManyPlacementsResponseDtoPropertyEnum = {
    New: 'NEW',
    Hot: 'HOT',
    Personal: 'PERSONAL',
    SameGoods: 'SAME_GOODS',
    DiffGoods: 'DIFF_GOODS'
} as const;

export type FetchManyPlacementsResponseDtoPropertyEnum = typeof FetchManyPlacementsResponseDtoPropertyEnum[keyof typeof FetchManyPlacementsResponseDtoPropertyEnum];

/**
 * 
 * @export
 * @interface FetchPageClientDto
 */
export interface FetchPageClientDto {
    /**
     * 
     * @type {string}
     * @memberof FetchPageClientDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FetchPageClientDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof FetchPageClientDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchPageClientDto
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {Client}
     * @memberof FetchPageClientDto
     */
    'client': Client;
}
/**
 * 
 * @export
 * @interface FetchProductResponseDto
 */
export interface FetchProductResponseDto {
    /**
     * 
     * @type {object}
     * @memberof FetchProductResponseDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'idOnStore': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'storeId': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'sellerId': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FetchProductResponseDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof FetchProductResponseDto
     */
    'includeInRecommendation': boolean;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'deepLink': string | null;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'caption': string | null;
    /**
     * 
     * @type {Array<Placement>}
     * @memberof FetchProductResponseDto
     */
    'placements': Array<Placement>;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FetchProductResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {Client}
     * @memberof FetchProductResponseDto
     */
    'store': Client;
    /**
     * 
     * @type {Client}
     * @memberof FetchProductResponseDto
     */
    'seller': Client;
}
/**
 * 
 * @export
 * @interface GridInjector
 */
export interface GridInjector {
    /**
     * 
     * @type {Array<string>}
     * @memberof GridInjector
     */
    'paths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GridInjector
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface GridInjectorDto
 */
export interface GridInjectorDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GridInjectorDto
     */
    'paths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GridInjectorDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface ImpressionObserver
 */
export interface ImpressionObserver {
    /**
     * 
     * @type {boolean}
     * @memberof ImpressionObserver
     */
    'useIntersectionObserver'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImpressionObserver
     */
    'className'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImpressionObserver
     */
    'wrapper'?: string;
}
/**
 * 
 * @export
 * @interface Injector
 */
export interface Injector {
    /**
     * 
     * @type {Retriever}
     * @memberof Injector
     */
    'retriever'?: Retriever;
    /**
     * 
     * @type {ImpressionObserver}
     * @memberof Injector
     */
    'impressionObserver'?: ImpressionObserver;
    /**
     * 
     * @type {Observer}
     * @memberof Injector
     */
    'observer'?: Observer;
    /**
     * 
     * @type {GridInjector}
     * @memberof Injector
     */
    'grid'?: GridInjector;
    /**
     * 
     * @type {BannerInjector}
     * @memberof Injector
     */
    'banner'?: BannerInjector;
    /**
     * 
     * @type {AppendInjector}
     * @memberof Injector
     */
    'append'?: AppendInjector;
    /**
     * 
     * @type {WidgetInjector}
     * @memberof Injector
     */
    'widget'?: WidgetInjector;
}
/**
 * 
 * @export
 * @interface LogOptionsDto
 */
export interface LogOptionsDto {
    /**
     * 
     * @type {string}
     * @memberof LogOptionsDto
     */
    'requestId': string;
    /**
     * 
     * @type {string}
     * @memberof LogOptionsDto
     */
    'adsetId': string;
}
/**
 * 
 * @export
 * @interface NestJSErrorSchema
 */
export interface NestJSErrorSchema {
    /**
     * 
     * @type {number}
     * @memberof NestJSErrorSchema
     */
    'statusCode': number;
    /**
     * 
     * @type {object}
     * @memberof NestJSErrorSchema
     */
    'message': object;
    /**
     * 
     * @type {string}
     * @memberof NestJSErrorSchema
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface Observer
 */
export interface Observer {
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    'impressedClassName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    'wrapper'?: string;
}
/**
 * 
 * @export
 * @interface Placement
 */
export interface Placement {
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'type': PlacementTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'suggestionType': PlacementSuggestionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'supportEnvironment': PlacementSupportEnvironmentEnum;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'developEnvironment': PlacementDevelopEnvironmentEnum;
    /**
     * 
     * @type {number}
     * @memberof Placement
     */
    'displayCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof Placement
     */
    'minDisplayCount': number;
    /**
     * 
     * @type {number}
     * @memberof Placement
     */
    'maxDisplayCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof Placement
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'pageName': string;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'clientId': string;
    /**
     * 
     * @type {Injector}
     * @memberof Placement
     */
    'injector': Injector | null;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'screenShot': string;
    /**
     * 
     * @type {number}
     * @memberof Placement
     */
    'displayFormatWidth': number | null;
    /**
     * 
     * @type {number}
     * @memberof Placement
     */
    'displayFormatHeight': number | null;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'property': PlacementPropertyEnum;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'placementFormatRatio': string | null;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Placement
     */
    'deletedAt': string | null;
}

export const PlacementTypeEnum = {
    Grid: 'GRID',
    Banner: 'BANNER'
} as const;

export type PlacementTypeEnum = typeof PlacementTypeEnum[keyof typeof PlacementTypeEnum];
export const PlacementSuggestionTypeEnum = {
    Recommend: 'RECOMMEND',
    Advertise: 'ADVERTISE'
} as const;

export type PlacementSuggestionTypeEnum = typeof PlacementSuggestionTypeEnum[keyof typeof PlacementSuggestionTypeEnum];
export const PlacementSupportEnvironmentEnum = {
    Web: 'WEB',
    WebMobile: 'WEB_MOBILE',
    App: 'APP'
} as const;

export type PlacementSupportEnvironmentEnum = typeof PlacementSupportEnvironmentEnum[keyof typeof PlacementSupportEnvironmentEnum];
export const PlacementDevelopEnvironmentEnum = {
    Widget: 'WIDGET',
    SelfDeveloped: 'SELF_DEVELOPED',
    CodeInjector: 'CODE_INJECTOR'
} as const;

export type PlacementDevelopEnvironmentEnum = typeof PlacementDevelopEnvironmentEnum[keyof typeof PlacementDevelopEnvironmentEnum];
export const PlacementPropertyEnum = {
    New: 'NEW',
    Hot: 'HOT',
    Personal: 'PERSONAL',
    SameGoods: 'SAME_GOODS',
    DiffGoods: 'DIFF_GOODS'
} as const;

export type PlacementPropertyEnum = typeof PlacementPropertyEnum[keyof typeof PlacementPropertyEnum];

/**
 * 
 * @export
 * @interface PlacementControllerFetchMany200Response
 */
export interface PlacementControllerFetchMany200Response {
    /**
     * 
     * @type {number}
     * @memberof PlacementControllerFetchMany200Response
     */
    'count'?: number;
    /**
     * 
     * @type {Array<FetchManyPlacementsResponseDto>}
     * @memberof PlacementControllerFetchMany200Response
     */
    'items'?: Array<FetchManyPlacementsResponseDto>;
}
/**
 * 
 * @export
 * @interface PlacementFormat
 */
export interface PlacementFormat {
    /**
     * 
     * @type {string}
     * @memberof PlacementFormat
     */
    'ratio': string;
    /**
     * 
     * @type {Array<Creative>}
     * @memberof PlacementFormat
     */
    'creatives': Array<Creative>;
    /**
     * 
     * @type {Array<Placement>}
     * @memberof PlacementFormat
     */
    'placements': Array<Placement>;
}
/**
 * 
 * @export
 * @interface PlacementInjectorDto
 */
export interface PlacementInjectorDto {
    /**
     * 
     * @type {GridInjectorDto}
     * @memberof PlacementInjectorDto
     */
    'grid'?: GridInjectorDto;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {object}
     * @memberof Product
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'idOnStore': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'storeId': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sellerId': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'includeInRecommendation': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'deepLink': string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'caption': string | null;
    /**
     * 
     * @type {Array<Placement>}
     * @memberof Product
     */
    'placements': Array<Placement>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ProductControllerFetchMany200Response
 */
export interface ProductControllerFetchMany200Response {
    /**
     * 
     * @type {number}
     * @memberof ProductControllerFetchMany200Response
     */
    'count'?: number;
    /**
     * 
     * @type {Array<FetchProductResponseDto>}
     * @memberof ProductControllerFetchMany200Response
     */
    'items'?: Array<FetchProductResponseDto>;
}
/**
 * 
 * @export
 * @interface Retriever
 */
export interface Retriever {
    /**
     * 
     * @type {string}
     * @memberof Retriever
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof Retriever
     */
    'attribute': string;
    /**
     * 
     * @type {string}
     * @memberof Retriever
     */
    'matcher'?: RetrieverMatcherEnum;
}

export const RetrieverMatcherEnum = {
    Exact: 'exact',
    EndsWith: 'endsWith',
    StartsWith: 'startsWith',
    Contains: 'contains'
} as const;

export type RetrieverMatcherEnum = typeof RetrieverMatcherEnum[keyof typeof RetrieverMatcherEnum];

/**
 * 
 * @export
 * @interface Store
 */
export interface Store {
    /**
     * 
     * @type {string}
     * @memberof Store
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Store
     */
    'type': StoreTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Store
     */
    'solutionType': StoreSolutionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Store
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Store
     */
    'deletedAt': string | null;
}

export const StoreTypeEnum = {
    Platform: 'PLATFORM',
    InHouse: 'IN_HOUSE'
} as const;

export type StoreTypeEnum = typeof StoreTypeEnum[keyof typeof StoreTypeEnum];
export const StoreSolutionTypeEnum = {
    SelfDeveloped: 'SELF_DEVELOPED',
    Cafe24: 'CAFE24'
} as const;

export type StoreSolutionTypeEnum = typeof StoreSolutionTypeEnum[keyof typeof StoreSolutionTypeEnum];

/**
 * 
 * @export
 * @interface SuggestionDto
 */
export interface SuggestionDto {
    /**
     * 
     * @type {LogOptionsDto}
     * @memberof SuggestionDto
     */
    'logOptions': LogOptionsDto;
    /**
     * 
     * @type {Product}
     * @memberof SuggestionDto
     */
    'product'?: Product;
    /**
     * 
     * @type {BannerWithCreativeDto}
     * @memberof SuggestionDto
     */
    'banner'?: BannerWithCreativeDto;
}
/**
 * 
 * @export
 * @interface SuggestionRequestDto
 */
export interface SuggestionRequestDto {
    /**
     * The session starts when the customer visits the store. It persists until the customer closes the tab, browser or app.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'sessionId': string;
    /**
     * The device identifier should be unique for each device. A customer can have multiple devices.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'deviceId': string;
    /**
     * The customer identifier which is generated and managed by the store. The store should configure `frontApi` parameter of ADCIO SDK so that the `customerId` can be sent to ADCIO API.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'customerId'?: string;
    /**
     * Identifier for the placement which the suggestion will be placed.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'placementId': string;
    /**
     * The X coordinate of the placement in pixel.
     * @type {number}
     * @memberof SuggestionRequestDto
     */
    'placementPositionX'?: number;
    /**
     * The Y coordinate of the placement in pixel.
     * @type {number}
     * @memberof SuggestionRequestDto
     */
    'placementPositionY'?: number;
    /**
     * Whether the request is from the ADCIO agent or not. Default value is `false`.
     * @type {boolean}
     * @memberof SuggestionRequestDto
     */
    'fromAgent'?: boolean;
    /**
     * The age of the customer.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'age'?: SuggestionRequestDtoAgeEnum;
    /**
     * The gender of the customer.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'gender'?: SuggestionRequestDtoGenderEnum;
    /**
     * The geographical area of the customer.
     * @type {string}
     * @memberof SuggestionRequestDto
     */
    'area'?: SuggestionRequestDtoAreaEnum;
}

export const SuggestionRequestDtoAgeEnum = {
    _10: '10',
    _20: '20',
    _30: '30',
    _40: '40'
} as const;

export type SuggestionRequestDtoAgeEnum = typeof SuggestionRequestDtoAgeEnum[keyof typeof SuggestionRequestDtoAgeEnum];
export const SuggestionRequestDtoGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type SuggestionRequestDtoGenderEnum = typeof SuggestionRequestDtoGenderEnum[keyof typeof SuggestionRequestDtoGenderEnum];
export const SuggestionRequestDtoAreaEnum = {
    NorthernVietnam: 'NorthernVietnam',
    SouthernVietnam: 'SouthernVietnam'
} as const;

export type SuggestionRequestDtoAreaEnum = typeof SuggestionRequestDtoAreaEnum[keyof typeof SuggestionRequestDtoAreaEnum];

/**
 * 
 * @export
 * @interface SuggestionResponseDto
 */
export interface SuggestionResponseDto {
    /**
     * 
     * @type {Array<SuggestionDto>}
     * @memberof SuggestionResponseDto
     */
    'suggestions': Array<SuggestionDto>;
    /**
     * 
     * @type {SuggestionResponsePlacementType}
     * @memberof SuggestionResponseDto
     */
    'placement': SuggestionResponsePlacementType;
}
/**
 * 
 * @export
 * @interface SuggestionResponsePlacementType
 */
export interface SuggestionResponsePlacementType {
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'type': SuggestionResponsePlacementTypeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'suggestionType': SuggestionResponsePlacementTypeSuggestionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'supportEnvironment': SuggestionResponsePlacementTypeSupportEnvironmentEnum;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'developEnvironment': SuggestionResponsePlacementTypeDevelopEnvironmentEnum;
    /**
     * 
     * @type {number}
     * @memberof SuggestionResponsePlacementType
     */
    'displayCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof SuggestionResponsePlacementType
     */
    'minDisplayCount': number;
    /**
     * 
     * @type {number}
     * @memberof SuggestionResponsePlacementType
     */
    'maxDisplayCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof SuggestionResponsePlacementType
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'pageName': string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'clientId': string;
    /**
     * 
     * @type {Injector}
     * @memberof SuggestionResponsePlacementType
     */
    'injector': Injector | null;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'screenShot': string;
    /**
     * 
     * @type {number}
     * @memberof SuggestionResponsePlacementType
     */
    'displayFormatWidth': number | null;
    /**
     * 
     * @type {number}
     * @memberof SuggestionResponsePlacementType
     */
    'displayFormatHeight': number | null;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'property': SuggestionResponsePlacementTypePropertyEnum;
    /**
     * 
     * @type {PlacementFormat}
     * @memberof SuggestionResponsePlacementType
     */
    'placementFormat': PlacementFormat | null;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'placementFormatRatio': string | null;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SuggestionResponsePlacementType
     */
    'deletedAt': string | null;
}

export const SuggestionResponsePlacementTypeTypeEnum = {
    Grid: 'GRID',
    Banner: 'BANNER'
} as const;

export type SuggestionResponsePlacementTypeTypeEnum = typeof SuggestionResponsePlacementTypeTypeEnum[keyof typeof SuggestionResponsePlacementTypeTypeEnum];
export const SuggestionResponsePlacementTypeSuggestionTypeEnum = {
    Recommend: 'RECOMMEND',
    Advertise: 'ADVERTISE'
} as const;

export type SuggestionResponsePlacementTypeSuggestionTypeEnum = typeof SuggestionResponsePlacementTypeSuggestionTypeEnum[keyof typeof SuggestionResponsePlacementTypeSuggestionTypeEnum];
export const SuggestionResponsePlacementTypeSupportEnvironmentEnum = {
    Web: 'WEB',
    WebMobile: 'WEB_MOBILE',
    App: 'APP'
} as const;

export type SuggestionResponsePlacementTypeSupportEnvironmentEnum = typeof SuggestionResponsePlacementTypeSupportEnvironmentEnum[keyof typeof SuggestionResponsePlacementTypeSupportEnvironmentEnum];
export const SuggestionResponsePlacementTypeDevelopEnvironmentEnum = {
    Widget: 'WIDGET',
    SelfDeveloped: 'SELF_DEVELOPED',
    CodeInjector: 'CODE_INJECTOR'
} as const;

export type SuggestionResponsePlacementTypeDevelopEnvironmentEnum = typeof SuggestionResponsePlacementTypeDevelopEnvironmentEnum[keyof typeof SuggestionResponsePlacementTypeDevelopEnvironmentEnum];
export const SuggestionResponsePlacementTypePropertyEnum = {
    New: 'NEW',
    Hot: 'HOT',
    Personal: 'PERSONAL',
    SameGoods: 'SAME_GOODS',
    DiffGoods: 'DIFF_GOODS'
} as const;

export type SuggestionResponsePlacementTypePropertyEnum = typeof SuggestionResponsePlacementTypePropertyEnum[keyof typeof SuggestionResponsePlacementTypePropertyEnum];

/**
 * 
 * @export
 * @interface UpdateBannerDto
 */
export interface UpdateBannerDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBannerDto
     */
    'activated': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'name': string;
    /**
     * 
     * @type {Array<UpsertCreativeDto>}
     * @memberof UpdateBannerDto
     */
    'creatives': Array<UpsertCreativeDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBannerDto
     */
    'placementIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'url'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateBannerDto
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'startsAt': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'endsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'categoryId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateBannerDto
     */
    'productId': string | null;
}
/**
 * 
 * @export
 * @interface UpdatePlacementDto
 */
export interface UpdatePlacementDto {
    /**
     * 
     * @type {string}
     * @memberof UpdatePlacementDto
     */
    'title'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePlacementDto
     */
    'adsetIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePlacementDto
     */
    'activated'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'idOnStore'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'includeInRecommendation'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'sellerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'deepLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'caption'?: string | null;
}
/**
 * 
 * @export
 * @interface UpsertCreativeDto
 */
export interface UpsertCreativeDto {
    /**
     * 
     * @type {string}
     * @memberof UpsertCreativeDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertCreativeDto
     */
    'mediaUrl': string;
    /**
     * 
     * @type {number}
     * @memberof UpsertCreativeDto
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpsertCreativeDto
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpsertCreativeDto
     */
    'placementFormatRatio'?: string;
}
/**
 * 
 * @export
 * @interface UpsertManyProductDto
 */
export interface UpsertManyProductDto {
    /**
     * 
     * @type {Array<UpsertProductDto>}
     * @memberof UpsertManyProductDto
     */
    'data': Array<UpsertProductDto>;
}
/**
 * 
 * @export
 * @interface UpsertManyProductResponseDto
 */
export interface UpsertManyProductResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpsertManyProductResponseDto
     */
    'inserted': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpsertManyProductResponseDto
     */
    'nonRelated': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpsertManyProductResponseDto
     */
    'duplicatedIds': Array<string>;
}
/**
 * 
 * @export
 * @interface UpsertProductDto
 */
export interface UpsertProductDto {
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'idOnStore': string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UpsertProductDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertProductDto
     */
    'includeInRecommendation'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'sellerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'sellerIdOnStore'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'deepLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertProductDto
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface WidgetInjector
 */
export interface WidgetInjector {
    /**
     * 
     * @type {string}
     * @memberof WidgetInjector
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetInjector
     */
    'wrapper': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetInjector
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetInjector
     */
    'imageTemplate'?: string;
    /**
     * 
     * @type {string}
     * @memberof WidgetInjector
     */
    'videoTemplate'?: string;
    /**
     * 
     * @type {object}
     * @memberof WidgetInjector
     */
    'swiper'?: object;
}

/**
 * BannerApi - axios parameter creator
 * @export
 */
export const BannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBannerDto} createBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerCreate: async (createBannerDto: CreateBannerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBannerDto' is not null or undefined
            assertParamExists('bannerControllerCreate', 'createBannerDto', createBannerDto)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBannerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bannerControllerDelete', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [orderBy] BannerSortOption
         * @param {Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>} [select] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {Array<string>} [placementIds] 
         * @param {string} [startsAt] 
         * @param {string} [endsAt] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerFetchMany: async (orderBy?: Array<string>, select?: Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>, activated?: boolean, name?: string, placementIds?: Array<string>, startsAt?: string, endsAt?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (orderBy) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (activated !== undefined) {
                localVarQueryParameter['activated'] = activated;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (placementIds) {
                localVarQueryParameter['placementIds'] = placementIds;
            }

            if (startsAt !== undefined) {
                localVarQueryParameter['startsAt'] = (startsAt as any instanceof Date) ?
                    (startsAt as any).toISOString() :
                    startsAt;
            }

            if (endsAt !== undefined) {
                localVarQueryParameter['endsAt'] = (endsAt as any instanceof Date) ?
                    (endsAt as any).toISOString() :
                    endsAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerFetchOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bannerControllerFetchOne', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBannerDto} updateBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerUpdate: async (id: string, updateBannerDto: UpdateBannerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bannerControllerUpdate', 'id', id)
            // verify required parameter 'updateBannerDto' is not null or undefined
            assertParamExists('bannerControllerUpdate', 'updateBannerDto', updateBannerDto)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBannerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannerApi - functional programming interface
 * @export
 */
export const BannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBannerDto} createBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bannerControllerCreate(createBannerDto: CreateBannerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Banner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bannerControllerCreate(createBannerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bannerControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bannerControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [orderBy] BannerSortOption
         * @param {Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>} [select] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {Array<string>} [placementIds] 
         * @param {string} [startsAt] 
         * @param {string} [endsAt] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bannerControllerFetchMany(orderBy?: Array<string>, select?: Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>, activated?: boolean, name?: string, placementIds?: Array<string>, startsAt?: string, endsAt?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerControllerFetchMany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bannerControllerFetchMany(orderBy, select, activated, name, placementIds, startsAt, endsAt, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bannerControllerFetchOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchBannerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bannerControllerFetchOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBannerDto} updateBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bannerControllerUpdate(id: string, updateBannerDto: UpdateBannerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Banner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bannerControllerUpdate(id, updateBannerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BannerApi - factory interface
 * @export
 */
export const BannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBannerDto} createBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerCreate(createBannerDto: CreateBannerDto, options?: any): AxiosPromise<Banner> {
            return localVarFp.bannerControllerCreate(createBannerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.bannerControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [orderBy] BannerSortOption
         * @param {Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>} [select] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {Array<string>} [placementIds] 
         * @param {string} [startsAt] 
         * @param {string} [endsAt] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerFetchMany(orderBy?: Array<string>, select?: Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>, activated?: boolean, name?: string, placementIds?: Array<string>, startsAt?: string, endsAt?: string, limit?: number, offset?: number, options?: any): AxiosPromise<BannerControllerFetchMany200Response> {
            return localVarFp.bannerControllerFetchMany(orderBy, select, activated, name, placementIds, startsAt, endsAt, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerFetchOne(id: string, options?: any): AxiosPromise<FetchBannerResponseDto> {
            return localVarFp.bannerControllerFetchOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBannerDto} updateBannerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bannerControllerUpdate(id: string, updateBannerDto: UpdateBannerDto, options?: any): AxiosPromise<Banner> {
            return localVarFp.bannerControllerUpdate(id, updateBannerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannerApi - object-oriented interface
 * @export
 * @class BannerApi
 * @extends {BaseAPI}
 */
export class BannerApi extends BaseAPI {
    /**
     * 
     * @param {CreateBannerDto} createBannerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public bannerControllerCreate(createBannerDto: CreateBannerDto, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).bannerControllerCreate(createBannerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public bannerControllerDelete(id: string, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).bannerControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [orderBy] BannerSortOption
     * @param {Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>} [select] 
     * @param {boolean} [activated] 
     * @param {string} [name] 
     * @param {Array<string>} [placementIds] 
     * @param {string} [startsAt] 
     * @param {string} [endsAt] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public bannerControllerFetchMany(orderBy?: Array<string>, select?: Array<'id' | 'name' | 'imageUrl' | 'url' | 'data' | 'activated' | 'startsAt' | 'endsAt' | 'createdAt'>, activated?: boolean, name?: string, placementIds?: Array<string>, startsAt?: string, endsAt?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).bannerControllerFetchMany(orderBy, select, activated, name, placementIds, startsAt, endsAt, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public bannerControllerFetchOne(id: string, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).bannerControllerFetchOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateBannerDto} updateBannerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public bannerControllerUpdate(id: string, updateBannerDto: UpdateBannerDto, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).bannerControllerUpdate(id, updateBannerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlacementApi - axios parameter creator
 * @export
 */
export const PlacementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePlacementDto} createPlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerCreate: async (createPlacementDto: CreatePlacementDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlacementDto' is not null or undefined
            assertParamExists('placementControllerCreate', 'createPlacementDto', createPlacementDto)
            const localVarPath = `/placements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlacementDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>} [select] 
         * @param {string} [title] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {'GRID' | 'BANNER'} [type] 
         * @param {boolean} [activated] 
         * @param {'title' | 'createdAt'} [orderBy] 
         * @param {'ASC' | 'DESC'} [orderDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerFetchMany: async (limit?: number, offset?: number, select?: Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>, title?: string, startDate?: string, endDate?: string, type?: 'GRID' | 'BANNER', activated?: boolean, orderBy?: 'title' | 'createdAt', orderDir?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/placements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (activated !== undefined) {
                localVarQueryParameter['activated'] = activated;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDir !== undefined) {
                localVarQueryParameter['orderDir'] = orderDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerFetchOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placementControllerFetchOne', 'id', id)
            const localVarPath = `/placements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placementControllerRemove', 'id', id)
            const localVarPath = `/placements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePlacementDto} updatePlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerUpdate: async (id: string, updatePlacementDto: UpdatePlacementDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placementControllerUpdate', 'id', id)
            // verify required parameter 'updatePlacementDto' is not null or undefined
            assertParamExists('placementControllerUpdate', 'updatePlacementDto', updatePlacementDto)
            const localVarPath = `/placements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePlacementDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {File} screenShot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerUpdateScreenShot: async (id: string, screenShot: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('placementControllerUpdateScreenShot', 'id', id)
            // verify required parameter 'screenShot' is not null or undefined
            assertParamExists('placementControllerUpdateScreenShot', 'screenShot', screenShot)
            const localVarPath = `/placements/{id}/screenShot`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


            if (screenShot !== undefined) { 
                localVarFormParams.append('screenShot', screenShot as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlacementApi - functional programming interface
 * @export
 */
export const PlacementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlacementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePlacementDto} createPlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerCreate(createPlacementDto: CreatePlacementDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Placement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerCreate(createPlacementDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>} [select] 
         * @param {string} [title] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {'GRID' | 'BANNER'} [type] 
         * @param {boolean} [activated] 
         * @param {'title' | 'createdAt'} [orderBy] 
         * @param {'ASC' | 'DESC'} [orderDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerFetchMany(limit?: number, offset?: number, select?: Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>, title?: string, startDate?: string, endDate?: string, type?: 'GRID' | 'BANNER', activated?: boolean, orderBy?: 'title' | 'createdAt', orderDir?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacementControllerFetchMany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerFetchMany(limit, offset, select, title, startDate, endDate, type, activated, orderBy, orderDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerFetchOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Placement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerFetchOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePlacementDto} updatePlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerUpdate(id: string, updatePlacementDto: UpdatePlacementDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Placement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerUpdate(id, updatePlacementDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {File} screenShot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placementControllerUpdateScreenShot(id: string, screenShot: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placementControllerUpdateScreenShot(id, screenShot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlacementApi - factory interface
 * @export
 */
export const PlacementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlacementApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePlacementDto} createPlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerCreate(createPlacementDto: CreatePlacementDto, options?: any): AxiosPromise<Placement> {
            return localVarFp.placementControllerCreate(createPlacementDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>} [select] 
         * @param {string} [title] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {'GRID' | 'BANNER'} [type] 
         * @param {boolean} [activated] 
         * @param {'title' | 'createdAt'} [orderBy] 
         * @param {'ASC' | 'DESC'} [orderDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerFetchMany(limit?: number, offset?: number, select?: Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>, title?: string, startDate?: string, endDate?: string, type?: 'GRID' | 'BANNER', activated?: boolean, orderBy?: 'title' | 'createdAt', orderDir?: 'ASC' | 'DESC', options?: any): AxiosPromise<PlacementControllerFetchMany200Response> {
            return localVarFp.placementControllerFetchMany(limit, offset, select, title, startDate, endDate, type, activated, orderBy, orderDir, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerFetchOne(id: string, options?: any): AxiosPromise<Placement> {
            return localVarFp.placementControllerFetchOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.placementControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePlacementDto} updatePlacementDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerUpdate(id: string, updatePlacementDto: UpdatePlacementDto, options?: any): AxiosPromise<Placement> {
            return localVarFp.placementControllerUpdate(id, updatePlacementDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {File} screenShot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placementControllerUpdateScreenShot(id: string, screenShot: File, options?: any): AxiosPromise<void> {
            return localVarFp.placementControllerUpdateScreenShot(id, screenShot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlacementApi - object-oriented interface
 * @export
 * @class PlacementApi
 * @extends {BaseAPI}
 */
export class PlacementApi extends BaseAPI {
    /**
     * 
     * @param {CreatePlacementDto} createPlacementDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerCreate(createPlacementDto: CreatePlacementDto, options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerCreate(createPlacementDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>} [select] 
     * @param {string} [title] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {'GRID' | 'BANNER'} [type] 
     * @param {boolean} [activated] 
     * @param {'title' | 'createdAt'} [orderBy] 
     * @param {'ASC' | 'DESC'} [orderDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerFetchMany(limit?: number, offset?: number, select?: Array<'id' | 'title' | 'type' | 'suggestionType' | 'displayCount' | 'activated' | 'pageName' | 'clientId' | 'injector' | 'screenShot' | 'displayFormatWidth' | 'displayFormatHeight' | 'property' | 'placementFormatRatio' | 'createdAt' | 'updatedAt' | 'deletedAt'>, title?: string, startDate?: string, endDate?: string, type?: 'GRID' | 'BANNER', activated?: boolean, orderBy?: 'title' | 'createdAt', orderDir?: 'ASC' | 'DESC', options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerFetchMany(limit, offset, select, title, startDate, endDate, type, activated, orderBy, orderDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerFetchOne(id: string, options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerFetchOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerRemove(id: string, options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdatePlacementDto} updatePlacementDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerUpdate(id: string, updatePlacementDto: UpdatePlacementDto, options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerUpdate(id, updatePlacementDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {File} screenShot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacementApi
     */
    public placementControllerUpdateScreenShot(id: string, screenShot: File, options?: AxiosRequestConfig) {
        return PlacementApiFp(this.configuration).placementControllerUpdateScreenShot(id, screenShot, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate: async (createProductDto: CreateProductDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('productControllerCreate', 'createProductDto', createProductDto)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch many products.
         * @summary 
         * @param {Array<string>} [orderBy] ProductSortOption
         * @param {string} [sellerId] 
         * @param {string} [storeId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [placementId] 
         * @param {string} [categoryId] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {string} [idOnStore] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFetchMany: async (orderBy?: Array<string>, sellerId?: string, storeId?: string, startDate?: string, endDate?: string, placementId?: string, categoryId?: string, activated?: boolean, name?: string, idOnStore?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (orderBy) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (sellerId !== undefined) {
                localVarQueryParameter['sellerId'] = sellerId;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (placementId !== undefined) {
                localVarQueryParameter['placementId'] = placementId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (activated !== undefined) {
                localVarQueryParameter['activated'] = activated;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (idOnStore !== undefined) {
                localVarQueryParameter['idOnStore'] = idOnStore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch one product.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFetchOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerFetchOne', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk upsert products.
         * @summary 
         * @param {UpsertManyProductDto} upsertManyProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpsertMany: async (upsertManyProductDto: UpsertManyProductDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertManyProductDto' is not null or undefined
            assertParamExists('productControllerUpsertMany', 'upsertManyProductDto', upsertManyProductDto)
            const localVarPath = `/products/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertManyProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerCreate(createProductDto: CreateProductDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerCreate(createProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch many products.
         * @summary 
         * @param {Array<string>} [orderBy] ProductSortOption
         * @param {string} [sellerId] 
         * @param {string} [storeId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [placementId] 
         * @param {string} [categoryId] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {string} [idOnStore] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFetchMany(orderBy?: Array<string>, sellerId?: string, storeId?: string, startDate?: string, endDate?: string, placementId?: string, categoryId?: string, activated?: boolean, name?: string, idOnStore?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerFetchMany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFetchMany(orderBy, sellerId, storeId, startDate, endDate, placementId, categoryId, activated, name, idOnStore, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch one product.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFetchOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchProductResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFetchOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(id, updateProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk upsert products.
         * @summary 
         * @param {UpsertManyProductDto} upsertManyProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpsertMany(upsertManyProductDto: UpsertManyProductDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertManyProductResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpsertMany(upsertManyProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate(createProductDto: CreateProductDto, options?: any): AxiosPromise<Product> {
            return localVarFp.productControllerCreate(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch many products.
         * @summary 
         * @param {Array<string>} [orderBy] ProductSortOption
         * @param {string} [sellerId] 
         * @param {string} [storeId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [placementId] 
         * @param {string} [categoryId] 
         * @param {boolean} [activated] 
         * @param {string} [name] 
         * @param {string} [idOnStore] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFetchMany(orderBy?: Array<string>, sellerId?: string, storeId?: string, startDate?: string, endDate?: string, placementId?: string, categoryId?: string, activated?: boolean, name?: string, idOnStore?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ProductControllerFetchMany200Response> {
            return localVarFp.productControllerFetchMany(orderBy, sellerId, storeId, startDate, endDate, placementId, categoryId, activated, name, idOnStore, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch one product.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFetchOne(id: string, options?: any): AxiosPromise<FetchProductResponseDto> {
            return localVarFp.productControllerFetchOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: any): AxiosPromise<void> {
            return localVarFp.productControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk upsert products.
         * @summary 
         * @param {UpsertManyProductDto} upsertManyProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpsertMany(upsertManyProductDto: UpsertManyProductDto, options?: any): AxiosPromise<UpsertManyProductResponseDto> {
            return localVarFp.productControllerUpsertMany(upsertManyProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerCreate(createProductDto: CreateProductDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerCreate(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch many products.
     * @summary 
     * @param {Array<string>} [orderBy] ProductSortOption
     * @param {string} [sellerId] 
     * @param {string} [storeId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {string} [placementId] 
     * @param {string} [categoryId] 
     * @param {boolean} [activated] 
     * @param {string} [name] 
     * @param {string} [idOnStore] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFetchMany(orderBy?: Array<string>, sellerId?: string, storeId?: string, startDate?: string, endDate?: string, placementId?: string, categoryId?: string, activated?: boolean, name?: string, idOnStore?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFetchMany(orderBy, sellerId, storeId, startDate, endDate, placementId, categoryId, activated, name, idOnStore, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch one product.
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFetchOne(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFetchOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk upsert products.
     * @summary 
     * @param {UpsertManyProductDto} upsertManyProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerUpsertMany(upsertManyProductDto: UpsertManyProductDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerUpsertMany(upsertManyProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuggestionApi - axios parameter creator
 * @export
 */
export const SuggestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch a personalized suggestion.
         * @summary 
         * @param {SuggestionRequestDto} suggestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionControllerSuggest: async (suggestionRequestDto: SuggestionRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionRequestDto' is not null or undefined
            assertParamExists('suggestionControllerSuggest', 'suggestionRequestDto', suggestionRequestDto)
            const localVarPath = `/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionApi - functional programming interface
 * @export
 */
export const SuggestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SuggestionApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch a personalized suggestion.
         * @summary 
         * @param {SuggestionRequestDto} suggestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionControllerSuggest(suggestionRequestDto: SuggestionRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionControllerSuggest(suggestionRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SuggestionApi - factory interface
 * @export
 */
export const SuggestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SuggestionApiFp(configuration)
    return {
        /**
         * Fetch a personalized suggestion.
         * @summary 
         * @param {SuggestionRequestDto} suggestionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionControllerSuggest(suggestionRequestDto: SuggestionRequestDto, options?: any): AxiosPromise<SuggestionResponseDto> {
            return localVarFp.suggestionControllerSuggest(suggestionRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SuggestionApi - object-oriented interface
 * @export
 * @class SuggestionApi
 * @extends {BaseAPI}
 */
export class SuggestionApi extends BaseAPI {
    /**
     * Fetch a personalized suggestion.
     * @summary 
     * @param {SuggestionRequestDto} suggestionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestionApi
     */
    public suggestionControllerSuggest(suggestionRequestDto: SuggestionRequestDto, options?: AxiosRequestConfig) {
        return SuggestionApiFp(this.configuration).suggestionControllerSuggest(suggestionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}


